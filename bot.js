// bot.js
const puppeteer = require("puppeteer");

// Funci√≥n para obtener la hora actual formateada
function getCurrentTime() {
  const now = new Date();
  return now.toLocaleTimeString('es-ES', { 
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
}

(async () => {
  const email = process.env.PACKET_EMAIL;
  const password = process.env.PACKET_PASSWORD;

  if (!email || !password) {
    console.error("‚ùå Variables de entorno PACKET_EMAIL y PACKET_PASSWORD requeridas.");
    process.exit(1);
  }

  // Funci√≥n para extraer segundos del texto del temporizador
  function parseCountdownText(countdownText) {
    // Ejemplo: "06 hours 23 min 28 sec" -> { hours: 6, minutes: 23, seconds: 28 }
    const regex = /(\d+)\s*hours?\s*(\d+)\s*min\s*(\d+)\s*sec/;
    const match = countdownText.match(regex);
    
    if (match) {
      return {
        hours: parseInt(match[1], 10),
        minutes: parseInt(match[2], 10),
        seconds: parseInt(match[3], 10)
      };
    }
    // Si no coincide el formato, asumir 0 segundos para evitar errores
    console.warn(`‚ö†Ô∏è No se pudo parsear el texto del temporizador: "${countdownText}". Usando 0 segundos.`);
    return { hours: 0, minutes: 0, seconds: 0 };
  }

  // Funci√≥n para convertir tiempo a milisegundos
  function timeToMilliseconds(timeObj) {
    return (timeObj.hours * 3600 + timeObj.minutes * 60 + timeObj.seconds) * 1000;
  }

  // Funci√≥n para calcular la hora futura
  function getFutureTime(milliseconds) {
    const now = new Date();
    const future = new Date(now.getTime() + milliseconds);
    return future.toLocaleTimeString('es-ES', { 
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  let browser;
  let page;
  let isFirstRun = true;

  // Funci√≥n principal del ciclo
  async function runCycle() {
    try {
      if (isFirstRun) {
        console.log("üöÄ Iniciando bot de PacketShare...");
        browser = await puppeteer.launch({
          headless: "new",
          args: [
            "--no-sandbox",
            "--disable-setuid-sandbox",
            "--disable-dev-shm-usage",
            "--disable-gpu",
          ],
        });

        page = await browser.newPage();
        
        console.log("üåê Abriendo p√°gina de login...");
        const response = await page.goto("https://www.packetshare.io/login/", {
          waitUntil: "networkidle2",
          timeout: 30000,
        });
        console.log(`   Estado de carga: ${response.status()}`);

        // Esperar a que los campos de entrada est√©n disponibles
        console.log("üîç Esperando campos de login...");
        await page.waitForSelector('input[placeholder="Please enter the email"]', {
          timeout: 10000,
        });
        await page.waitForSelector('input[placeholder="Please enter password"]', {
          timeout: 10000,
        });
        await page.waitForSelector("div.btn.login", { timeout: 10000 });

        console.log("‚úçÔ∏è Escribiendo credenciales...");
        await page.type('input[placeholder="Please enter the email"]', email, {
          delay: 50,
        });
        await page.type('input[placeholder="Please enter password"]', password, {
          delay: 50,
        });

        console.log("üîë Enviando login...");
        await page.click("div.btn.login");

        // Esperar un poco despu√©s del clic o la posible redirecci√≥n
        console.log("‚è≥ Esperando respuesta...");
        await page.waitForTimeout(5000);

        const currentUrl = page.url();
        console.log(`üìç URL despu√©s del intento de login: ${currentUrl}`);

        if (!currentUrl.includes("/dashboard")) {
          throw new Error("No se pudo acceder al dashboard despu√©s del login");
        }

        console.log("‚úÖ Login exitoso. Redirigido a dashboard.");
        isFirstRun = false;
      } else {
        // En ciclos posteriores, solo refrescamos la p√°gina
        console.log("üîÑ Refrescando dashboard...");
        await page.reload({ waitUntil: "networkidle2", timeout: 30000 });
        await page.waitForTimeout(3000); // Esperar un poco despu√©s de refrescar
      }

      // Obtener balance actual con hora
      console.log("üîç Obteniendo balance actual...");
      await page.waitForSelector('div.money span', { timeout: 15000 });
      const balance = await page.$eval('div.money span', el => el.textContent);
      const currentTime = getCurrentTime();
      console.log(`üí∞ Balance actual a las ${currentTime} : ${balance}`);

      // Primer clic: Hacer clic en el elemento del premio
      console.log("üëÜ Haciendo primer clic en el elemento del premio...");
      const selectorGift = "#__nuxt > div.ucenter-header > div.header > div > div.flow-box > img";
      
      try {
        await page.waitForSelector(selectorGift, { timeout: 10000 });
        await page.click(selectorGift);
      } catch (e) {
        throw new Error(`No se pudo hacer clic en el elemento del premio: ${e.message}`);
      }

      // Esperar un momento para que se abra el popup
      console.log("‚è≥ Esperando apertura del popup...");
      await page.waitForTimeout(3000);

      // Verificar si aparece el bot√≥n de confirmaci√≥n o el conteo regresivo
      console.log("üîç Verificando contenido del popup...");

      // Intentar encontrar el bot√≥n de confirmaci√≥n
      const confirmButtonSelector = "body > div.dialog-flow-box > div > div.button";
      let prizeClaimed = false;
      
      try {
        await page.waitForSelector(confirmButtonSelector, { timeout: 5000 });
        console.log("‚úÖ Bot√≥n de confirmaci√≥n encontrado. Haciendo segundo clic para reclamar el premio...");
        await page.click(confirmButtonSelector);
        prizeClaimed = true;
        
        // Esperar un momento despu√©s de reclamar el premio
        console.log("‚è≥ Esperando despu√©s de reclamar el premio...");
        await page.waitForTimeout(5000);
        
        // Refrescar la p√°gina para obtener el balance actualizado
        console.log("üîÑ Refrescando p√°gina para obtener balance actualizado...");
        await page.reload({ waitUntil: "networkidle2", timeout: 30000 });
        await page.waitForTimeout(3000);
        
        // Verificar si el balance cambi√≥
        console.log("üîç Verificando si el balance cambi√≥...");
        await page.waitForSelector('div.money span', { timeout: 15000 });
        const newBalance = await page.$eval('div.money span', el => el.textContent);
        
        const newTime = getCurrentTime();
        if (newBalance !== balance) {
          console.log(`üéâ Balance incrementado a las ${newTime} : ${balance} ‚Üí ${newBalance}`);
        } else {
          console.log(`‚ÑπÔ∏è Balance sin cambios a las ${newTime} : ${balance} ‚Üí ${newBalance}`);
        }
        
        // Ahora verificar el nuevo conteo regresivo
        console.log("üîç Verificando nuevo conteo regresivo...");
        try {
          // Hacer clic nuevamente en el elemento del premio para ver el nuevo conteo
          console.log("üëÜ Haciendo clic para verificar nuevo conteo regresivo...");
          await page.waitForSelector(selectorGift, { timeout: 10000 });
          await page.click(selectorGift);
          
          // Esperar un momento para que se abra el popup
          await page.waitForTimeout(3000);
          
          // Verificar si aparece el conteo regresivo
          await page.waitForSelector('div.time', { timeout: 5000 });
          const countdownText = await page.$eval('div.time', el => el.textContent);
          console.log(`‚è±Ô∏è Nuevo conteo regresivo encontrado: ${countdownText.trim()}`);
          
          // Parsear el tiempo y calcular espera
          const timeObj = parseCountdownText(countdownText.trim());
          const waitTimeMs = timeToMilliseconds(timeObj) + 20000; // +20 segundos
          
          // Programar el pr√≥ximo ciclo
          const futureTime = getFutureTime(waitTimeMs);
          const minutes = (waitTimeMs / 1000 / 60).toFixed(2);
          console.log(`‚è∞ Pr√≥ximo intento en a las ${futureTime} que son aproximadamente ${minutes} minutos...`);
          
          // Cerrar la posible ventana emergente si existe
          try {
            const closeButtonSelector = "body > div.dialog-flow-box > div > img.close-button";
            await page.waitForSelector(closeButtonSelector, { timeout: 3000 });
            await page.click(closeButtonSelector);
            console.log("‚ùå Ventana emergente cerrada autom√°ticamente.");
          } catch (e) {
            console.log("‚ÑπÔ∏è No se encontr√≥ ventana emergente para cerrar (esto es normal).");
          }
          
          // Esperar el tiempo calculado antes de repetir
          setTimeout(runCycle, waitTimeMs);
          
        } catch (countdownError) {
          console.log("‚ö†Ô∏è No se pudo obtener el nuevo conteo regresivo. Reintentando en 5 minutos...");
          setTimeout(runCycle, 300000); // 5 minutos
        }
        
      } catch (confirmButtonError) {
        // Si no se encuentra el bot√≥n de confirmaci√≥n, verificar si hay conteo regresivo
        console.log("‚ÑπÔ∏è No se encontr√≥ bot√≥n de confirmaci√≥n. Verificando si hay conteo regresivo...");
        
        try {
          await page.waitForSelector('div.time', { timeout: 5000 });
          const countdownText = await page.$eval('div.time', el => el.textContent);
          console.log(`‚è≥ Conteo regresivo encontrado: ${countdownText.trim()}`);
          
          // Parsear el tiempo y calcular espera
          const timeObj = parseCountdownText(countdownText.trim());
          const waitTimeMs = timeToMilliseconds(timeObj) + 20000; // +20 segundos
          
          // Programar el pr√≥ximo ciclo
          const futureTime = getFutureTime(waitTimeMs);
          const minutes = (waitTimeMs / 1000 / 60).toFixed(2);
          console.log(`‚è∞ Pr√≥ximo intento en a las ${futureTime} que son aproximadamente ${minutes} minutos...`);
          
          // Cerrar la posible ventana emergente si existe
          try {
            const closeButtonSelector = "body > div.dialog-flow-box > div > img.close-button";
            await page.waitForSelector(closeButtonSelector, { timeout: 3000 });
            await page.click(closeButtonSelector);
            console.log("‚ùå Ventana emergente cerrada autom√°ticamente.");
          } catch (e) {
            console.log("‚ÑπÔ∏è No se encontr√≥ ventana emergente para cerrar (esto es normal).");
          }
          
          // Esperar el tiempo calculado antes de repetir
          setTimeout(runCycle, waitTimeMs);
          
        } catch (countdownError) {
          console.log("‚ö†Ô∏è No se encontr√≥ ni bot√≥n de confirmaci√≥n ni conteo regresivo. Reintentando en 5 minutos...");
          setTimeout(runCycle, 300000); // 5 minutos
        }
      }

    } catch (err) {
      console.error("‚ö†Ô∏è Error en el ciclo:", err.message);
      
      // Intentar reconectar en caso de error
      if (browser) {
        try {
          await browser.close();
        } catch (closeErr) {
          console.error("‚ö†Ô∏è Error al cerrar el navegador:", closeErr.message);
        }
      }
      
      // Reiniciar despu√©s de 60 segundos
      console.log("üîÑ Intentando reconectar en 60 segundos...");
      setTimeout(() => {
        isFirstRun = true; // Forzar relogin
        runCycle();
      }, 60000);
    }
  }

  // Iniciar el primer ciclo
  runCycle();

  // Manejar se√±ales de cierre limpiamente
  process.on('SIGINT', async () => {
    console.log("\nüõë Recibida se√±al de interrupci√≥n. Cerrando...");
    if (browser) {
      await browser.close();
    }
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    console.log("\nüõë Recibida se√±al de terminaci√≥n. Cerrando...");
    if (browser) {
      await browser.close();
    }
    process.exit(0);
  });

})();
